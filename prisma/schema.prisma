generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // directUrl = env("DIRECT_URL") //uncomment for supabase
}

model User {
  id            String    @id
  createdAt     DateTime
  updatedAt     DateTime? @updatedAt
  name          String
  email         String    @unique
  emailVerified Boolean
  image         String?
  bio           String?

  // images → direct URL uploads
  avatarImageUrl String?
  coverImageUrl  String?

  // images → UploadThing keys
  avatarImageUTKey String?
  coverImageUTKey  String?

  // images → DB relations
  avatarImageId  String?   @unique
  avatarImage    UTImage?  @relation("AvatarImage", fields: [avatarImageId], references: [id], onDelete: SetNull)
  coverImageId   String?   @unique
  coverImage     UTImage?  @relation("CoverImage", fields: [coverImageId], references: [id], onDelete: SetNull)
  uploadedImages UTImage[] @relation("UploadedImages") // Relation for all uploaded images by user

  timezone String? @default("Etc/GMT")

  preferences Json? @default("{}")

  sessions Session[]
  accounts Account[]

  // better-auth-admin
  role       String    @default("user")
  banReason  String?
  banExpires DateTime?
  banned     Boolean   @default(false)

  // better-auth-username
  username        String?
  displayUsername String?

  onboarded Boolean @default(false)

  @@unique([username])
  @@map("users")
}

model Session {
  id             String    @id
  expiresAt      DateTime
  token          String    @unique
  createdAt      DateTime
  updatedAt      DateTime? @updatedAt
  ipAddress      String?
  userAgent      String?
  userId         String
  user           User      @relation(fields: [userId], references: [id])
  impersonatedBy String?

  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id])
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime? @updatedAt

  @@map("accounts")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime? @updatedAt

  @@map("verifications")
}

model UTImage {
  id        String   @id @default(cuid())
  key       String   @unique // The key returned by UploadThing
  userId    String
  user      User     @relation("UploadedImages", fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  usedAsAvatarByUser User? @relation("AvatarImage")
  usedAsCoverByUser  User? @relation("CoverImage")

  @@index([userId])
  @@map("ut_images")
}

// ============================================================================
// CLINICAL MODELS - Phase 2A Standalone Mode
// ============================================================================

model Tenant {
  id                String   @id @default(uuid())
  name              String
  operatingMode     OperatingMode @default(STANDALONE)
  isDedicatedDb     Boolean  @default(false)
  dbConnectionUri   String?
  adminCanChangeMode Boolean @default(true)
  requiresApproval  Boolean  @default(false)
  
  // Feature flags
  features          Json     @default("{\"manualExport\": true, \"patientManagement\": true, \"ehrSync\": false}")
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // Relations
  patients          Patient[]
  consultations     Consultation[]
  clinicalNotes     ClinicalNote[]
  exports           Export[]
  
  @@map("tenants")
}

model Patient {
  id              String   @id @default(uuid())
  tenantId        String
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  // External references
  ehrPatientId    String?  // populated after EHR migration
  source          PatientSource @default(ARIA_SCRIBE)
  
  // Demographics
  firstName       String
  lastName        String
  dateOfBirth     DateTime?
  gender          Gender?
  
  // Contact info
  phone           String?
  email           String?
  address         Json?    // Flexible address structure
  
  // Clinical metadata
  lastConsultation DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  consultations   Consultation[]
  clinicalNotes   ClinicalNote[]
  
  @@index([tenantId])
  @@index([tenantId, lastName, firstName])
  @@map("patients")
}

model Consultation {
  id              String   @id @default(uuid())
  tenantId        String
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  patientId       String
  patient         Patient  @relation(fields: [patientId], references: [id], onDelete: Cascade)
  
  // Session metadata
  mode            OperatingMode
  status          ConsultationStatus @default(READY)
  
  // Recording data
  recordingStartTime DateTime?
  recordingEndTime   DateTime?
  audioFileUrl       String?
  
  // Processing data
  transcriptionText  String?
  selectedTemplate   String?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  clinicalNotes   ClinicalNote[]
  exports         Export[]
  
  @@index([tenantId])
  @@index([tenantId, patientId])
  @@index([tenantId, status])
  @@map("consultations")
}

model ClinicalNote {
  id              String   @id @default(uuid())
  tenantId        String
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  patientId       String
  patient         Patient  @relation(fields: [patientId], references: [id], onDelete: Cascade)
  consultationId  String?
  consultation    Consultation? @relation(fields: [consultationId], references: [id], onDelete: SetNull)
  
  // Note content
  title           String
  content         String   // Markdown format
  noteType        NoteType @default(PROGRESS)
  template        String?
  
  // Status and workflow
  status          NoteStatus @default(DRAFT)
  
  // AI/Transcription metadata
  generatedFromAudio Boolean @default(false)
  transcriptionId    String?
  aiConfidence       Float?
  manuallyEdited     Boolean @default(false)
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  signedAt        DateTime?
  
  @@index([tenantId])
  @@index([tenantId, patientId])
  @@index([tenantId, status])
  @@map("clinical_notes")
}

model Export {
  id              String   @id @default(uuid())
  tenantId        String
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  consultationId  String
  consultation    Consultation @relation(fields: [consultationId], references: [id], onDelete: Cascade)
  
  // Export metadata
  format          ExportFormat
  filePath        String?  // Local file path or cloud URL
  fileName        String
  fileSize        Int?     // bytes
  
  // Status
  status          ExportStatus @default(PENDING)
  error           String?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([tenantId])
  @@index([tenantId, consultationId])
  @@map("exports")
}

// ============================================================================
// ENUMS
// ============================================================================

enum OperatingMode {
  STANDALONE
  EHR_INTEGRATED
}

enum PatientSource {
  ARIA_SCRIBE
  EHR
  IMPORTED
}

enum Gender {
  M
  F
  OTHER
  UNKNOWN
}

enum ConsultationStatus {
  READY
  RECORDING
  PROCESSING
  REVIEW
  COMPLETE
  ERROR
}

enum NoteType {
  PROGRESS
  SOAP
  ASSESSMENT
  PLAN
  REFERRAL
  OTHER
}

enum NoteStatus {
  DRAFT
  PENDING_REVIEW
  FINAL
  AMENDED
  SIGNED
}

enum ExportFormat {
  PDF
  DOCX
  TXT
}

enum ExportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}
